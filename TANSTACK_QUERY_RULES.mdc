---
description: When we are making api calls from the front end. 
alwaysApply: false
---
### 3. Query Hooks Pattern (Data Fetching)

**MANDATORY**: All data fetching MUST use `useQuery` hook.

#### Rules:
- ✅ **DO**: Create custom hooks for each API endpoint
- ✅ **DO**: Use query keys that are descriptive and hierarchical
- ✅ **DO**: Export query keys as constants for reuse
- ✅ **DO**: Use TypeScript types for query data
- ❌ **DON'T**: Fetch data directly in components
- ❌ **DON'T**: Use `useEffect` for data fetching

#### Query Keys Organization:

**File**: `lib/queries/queryKeys.ts`
```typescript
export const queryKeys = {
  // Waitlist queries
  waitlist: {
    all: ["waitlist"] as const,
    lists: () => [...queryKeys.waitlist.all, "list"] as const,
    list: (filters: string) => [...queryKeys.waitlist.lists(), { filters }] as const,
    details: () => [...queryKeys.waitlist.all, "detail"] as const,
    detail: (id: string) => [...queryKeys.waitlist.details(), id] as const,
  },
  
  // Video generation queries
  videoGeneration: {
    all: ["videoGeneration"] as const,
    results: () => [...queryKeys.videoGeneration.all, "results"] as const,
    result: (id: string) => [...queryKeys.videoGeneration.results(), id] as const,
    status: (id: string) => [...queryKeys.videoGeneration.all, "status", id] as const,
  },
  
  // User queries
  user: {
    all: ["user"] as const,
    current: () => [...queryKeys.user.all, "current"] as const,
    profile: (id: string) => [...queryKeys.user.all, "profile", id] as const,
  },
} as const;
```

#### Custom Query Hook Example:

**File**: `lib/queries/useWaitlist.ts`
```typescript
import { useQuery } from "@tanstack/react-query";
import { queryKeys } from "./queryKeys";

interface WaitlistResponse {
  success: boolean;
  message: string;
  email: string;
}

async function fetchWaitlistStatus(email: string): Promise<WaitlistResponse> {
  const response = await fetch(`/api/waitlist/status?email=${email}`);
  
  if (!response.ok) {
    throw new Error("Failed to fetch waitlist status");
  }
  
  return response.json();
}

export function useWaitlistStatus(email: string | null) {
  return useQuery<WaitlistResponse>({
    queryKey: queryKeys.waitlist.detail(email || ""),
    queryFn: () => fetchWaitlistStatus(email!),
    enabled: !!email, // Only run query if email exists
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}
```

#### Component Usage:

```typescript
import { useWaitlistStatus } from "@/lib/queries/useWaitlist";

export function WaitlistComponent() {
  const { data, isLoading, error } = useWaitlistStatus("user@example.com");
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{data?.message}</div>;
}
```

---

### 4. Mutation Hooks Pattern (Data Modifications)

**MANDATORY**: All data modifications MUST use `useMutation` hook.

#### Rules:
- ✅ **DO**: Create custom mutation hooks for each API endpoint
- ✅ **DO**: Use `onSuccess` and `onError` callbacks appropriately
- ✅ **DO**: Invalidate related queries after successful mutations
- ✅ **DO**: Use optimistic updates when appropriate
- ✅ **DO**: Reset form on successful mutation
- ❌ **DON'T**: Use `useState` for mutation loading/error states
- ❌ **DON'T**: Manually handle loading states

#### Custom Mutation Hook Example:

**File**: `lib/mutations/useWaitlistMutation.ts`
```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { queryKeys } from "../queries/queryKeys";
import { waitlistSchema } from "@/lib/schemas/waitlist.schema";
import type { WaitlistFormData } from "@/lib/schemas/waitlist.schema";

interface WaitlistResponse {
  success: boolean;
  message: string;
  email: string;
}

async function joinWaitlist(data: WaitlistFormData): Promise<WaitlistResponse> {
  const response = await fetch("/api/waitlist", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || "Failed to join waitlist");
  }
  
  return response.json();
}

export function useWaitlistMutation() {
  const queryClient = useQueryClient();
  
  return useMutation<WaitlistResponse, Error, WaitlistFormData>({
    mutationFn: joinWaitlist,
    onSuccess: (data) => {
      // Invalidate and refetch waitlist queries
      queryClient.invalidateQueries({ 
        queryKey: queryKeys.waitlist.all 
      });
      
      // Optionally set query data directly
      queryClient.setQueryData(
        queryKeys.waitlist.detail(data.email),
        data
      );
    },
    onError: (error) => {
      // Handle error (e.g., show toast notification)
      console.error("Waitlist mutation error:", error);
    },
  });
}
```

#### Component Usage with Form:

```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useWaitlistMutation } from "@/lib/mutations/useWaitlistMutation";
import { waitlistSchema, type WaitlistFormData } from "@/lib/schemas/waitlist.schema";
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/app/components/ui/form";

export function WaitlistForm() {
  const mutation = useWaitlistMutation();
  const form = useForm<WaitlistFormData>({
    resolver: zodResolver(waitlistSchema),
    defaultValues: {
      email: "",
      name: "",
    },
  });
  
  const onSubmit = async (data: WaitlistFormData) => {
    mutation.mutate(data, {
      onSuccess: () => {
        form.reset();
        // Show success message
      },
    });
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input {...field} disabled={mutation.isPending} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button 
          type="submit" 
          disabled={mutation.isPending}
        >
          {mutation.isPending ? "Joining..." : "Join Waitlist"}
        </Button>
        {mutation.isError && (
          <p className="text-red-500">{mutation.error.message}</p>
        )}
      </form>
    </Form>
  );
}
```

---

### 5. Query Invalidation and Cache Management

#### Rules:
- ✅ **DO**: Invalidate queries after mutations that affect the data
- ✅ **DO**: Use specific query keys for targeted invalidation
- ✅ **DO**: Use `setQueryData` for optimistic updates
- ✅ **DO**: Use `refetchQueries` when immediate refetch is needed
- ❌ **DON'T**: Invalidate all queries unnecessarily
- ❌ **DON'T**: Manually clear cache without reason

#### Invalidation Patterns:

```typescript
// Invalidate all waitlist queries
queryClient.invalidateQueries({ 
  queryKey: queryKeys.waitlist.all 
});

// Invalidate specific query
queryClient.invalidateQueries({ 
  queryKey: queryKeys.waitlist.detail(email) 
});

// Invalidate and refetch immediately
queryClient.invalidateQueries({ 
  queryKey: queryKeys.waitlist.all,
  refetchType: "active" // Only refetch active queries
});

// Set query data directly (optimistic update)
queryClient.setQueryData(
  queryKeys.waitlist.detail(email),
  newData
);

// Remove query from cache
queryClient.removeQueries({ 
  queryKey: queryKeys.waitlist.detail(email) 
});
```

---

### 6. Error Handling

#### Rules:
- ✅ **DO**: Handle errors in mutation `onError` callbacks
- ✅ **DO**: Display user-friendly error messages
- ✅ **DO**: Use error boundaries for query errors
- ✅ **DO**: Log errors for debugging
- ❌ **DON'T**: Swallow errors silently
- ❌ **DON'T**: Show technical error messages to users

#### Error Handling Pattern:

```typescript
import { useMutation } from "@tanstack/react-query";
import { toast } from "sonner"; // or your toast library

export function useWaitlistMutation() {
  return useMutation({
    mutationFn: joinWaitlist,
    onError: (error: Error) => {
      // Log for debugging
      console.error("Waitlist mutation error:", error);
      
      // Show user-friendly message
      toast.error(
        error.message || "Failed to join waitlist. Please try again."
      );
    },
  });
}
```

#### Query Error Handling:

```typescript
export function useWaitlistStatus(email: string | null) {
  return useQuery({
    queryKey: queryKeys.waitlist.detail(email || ""),
    queryFn: () => fetchWaitlistStatus(email!),
    enabled: !!email,
    retry: (failureCount, error) => {
      // Don't retry on 4xx errors
      if (error instanceof Error && error.message.includes("404")) {
        return false;
      }
      return failureCount < 3;
    },
    throwOnError: false, // Handle errors in component
  });
}
```

---

### 7. Loading States

#### Rules:
- ✅ **DO**: Use `isLoading` for initial load
- ✅ **DO**: Use `isFetching` for background refetches
- ✅ **DO**: Use `isPending` for mutations
- ✅ **DO**: Show loading skeletons or spinners
- ❌ **DON'T**: Show loading states unnecessarily
- ❌ **DON'T**: Block UI during background refetches

#### Loading State Pattern:

```typescript
export function WaitlistComponent() {
  const { data, isLoading, isFetching, error } = useWaitlistStatus(email);
  
  // Show skeleton on initial load
  if (isLoading) {
    return <WaitlistSkeleton />;
  }
  
  // Show error state
  if (error) {
    return <ErrorMessage error={error} />;
  }
  
  return (
    <div>
      {/* Show subtle indicator during background refetch */}
      {isFetching && <div className="text-xs">Updating...</div>}
      <WaitlistContent data={data} />
    </div>
  );
}
```

---

### 8. Optimistic Updates

#### Rules:
- ✅ **DO**: Use optimistic updates for better UX
- ✅ **DO**: Rollback on error
- ✅ **DO**: Use `onMutate` for optimistic updates
- ❌ **DON'T**: Use optimistic updates for critical operations
- ❌ **DON'T**: Skip error handling

#### Optimistic Update Pattern:

```typescript
export function useUpdateWaitlist() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateWaitlist,
    onMutate: async (newData) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ 
        queryKey: queryKeys.waitlist.all 
      });
      
      // Snapshot previous value
      const previousData = queryClient.getQueryData(
        queryKeys.waitlist.detail(newData.email)
      );
      
      // Optimistically update
      queryClient.setQueryData(
        queryKeys.waitlist.detail(newData.email),
        newData
      );
      
      // Return context with snapshot
      return { previousData };
    },
    onError: (err, newData, context) => {
      // Rollback on error
      queryClient.setQueryData(
        queryKeys.waitlist.detail(newData.email),
        context?.previousData
      );
    },
    onSettled: (data, error, variables) => {
      // Always refetch after error or success
      queryClient.invalidateQueries({
        queryKey: queryKeys.waitlist.detail(variables.email),
      });
    },
  });
}
```

---

### 9. Infinite Queries (Pagination)

#### Rules:
- ✅ **DO**: Use `useInfiniteQuery` for paginated data
- ✅ **DO**: Use `getNextPageParam` and `getPreviousPageParam`
- ✅ **DO**: Use `fetchNextPage` and `fetchPreviousPage`
- ❌ **DON'T**: Use regular `useQuery` for paginated data

#### Infinite Query Pattern:

```typescript
import { useInfiniteQuery } from "@tanstack/react-query";

interface PaginatedResponse {
  data: WaitlistItem[];
  nextCursor: string | null;
}

export function useInfiniteWaitlist() {
  return useInfiniteQuery<PaginatedResponse>({
    queryKey: queryKeys.waitlist.lists(),
    queryFn: ({ pageParam = null }) =>
      fetchWaitlist({ cursor: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    initialPageParam: null,
  });
}

// Component usage
export function WaitlistList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteWaitlist();
  
  const items = data?.pages.flatMap((page) => page.data) ?? [];
  
  return (
    <div>
      {items.map((item) => (
        <WaitlistItem key={item.id} item={item} />
      ))}
      {hasNextPage && (
        <Button
          onClick={() => fetchNextPage()}
          disabled={isFetchingNextPage}
        >
          {isFetchingNextPage ? "Loading..." : "Load More"}
        </Button>
      )}
    </div>
  );
}
```

---

### 10. Next.js App Router Integration

#### Rules:
- ✅ **DO**: Use TanStack Query in Client Components only
- ✅ **DO**: Prefetch data in Server Components when possible
- ✅ **DO**: Use `prefetchQuery` in Server Components
- ✅ **DO**: Use `dehydrate` and `HydrationBoundary` for SSR
- ❌ **DON'T**: Use TanStack Query in Server Components directly
- ❌ **DON'T**: Skip prefetching when data is available server-side

#### SSR Pattern:

**File**: `app/waitlist/page.tsx`
```typescript
import { QueryClient, dehydrate } from "@tanstack/react-query";
import { HydrationBoundary } from "@tanstack/react-query";
import { WaitlistComponent } from "./WaitlistComponent";
import { queryKeys } from "@/lib/queries/queryKeys";
import { fetchWaitlistStatus } from "@/lib/queries/useWaitlist";

export default async function WaitlistPage() {
  const queryClient = new QueryClient();
  
  // Prefetch data on server
  await queryClient.prefetchQuery({
    queryKey: queryKeys.waitlist.all,
    queryFn: () => fetchWaitlistStatus(),
  });
  
  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <WaitlistComponent />
    </HydrationBoundary>
  );
}
```

---

### 11. File Organization

#### Directory Structure:
```
lib/
  queries/
    queryKeys.ts          # All query keys
    useWaitlist.ts        # Waitlist queries
    useVideoGeneration.ts # Video generation queries
    useUser.ts            # User queries
    index.ts              # Re-exports
  
  mutations/
    useWaitlistMutation.ts
    useVideoGenerationMutation.ts
    useUserMutation.ts
    index.ts
  
  api/
    waitlist.ts           # API functions
    videoGeneration.ts
    user.ts
    index.ts
```

#### Query Hook File Pattern:

**File**: `lib/queries/useWaitlist.ts`
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { queryKeys } from "./queryKeys";
import * as waitlistApi from "@/lib/api/waitlist";

// Query hooks
export function useWaitlistStatus(email: string | null) {
  return useQuery({
    queryKey: queryKeys.waitlist.detail(email || ""),
    queryFn: () => waitlistApi.getStatus(email!),
    enabled: !!email,
  });
}

// Mutation hooks
export function useWaitlistMutation() {
  return useMutation({
    mutationFn: waitlistApi.join,
    // ... mutation config
  });
}
```

#### API Functions File Pattern:

**File**: `lib/api/waitlist.ts`
```typescript
import { waitlistSchema, type WaitlistFormData } from "@/lib/schemas/waitlist.schema";

export async function getStatus(email: string) {
  const response = await fetch(`/api/waitlist/status?email=${email}`);
  if (!response.ok) throw new Error("Failed to fetch status");
  return response.json();
}

export async function join(data: WaitlistFormData) {
  const response = await fetch("/api/waitlist", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data),
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || "Failed to join");
  }
  
  return response.json();
}
```

---

### 12. Migration from Existing Patterns

#### Before (Manual Fetch):
```typescript
export function WaitlistForm() {
  const [email, setEmail] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError("");
    
    try {
      const response = await fetch("/api/waitlist", {
        method: "POST",
        body: JSON.stringify({ email }),
      });
      
      if (!response.ok) throw new Error("Failed");
      // Handle success
    } catch (err) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

#### After (TanStack Query):
```typescript
export function WaitlistForm() {
  const form = useForm({
    resolver: zodResolver(waitlistSchema),
  });
  const mutation = useWaitlistMutation();
  
  const onSubmit = (data: WaitlistFormData) => {
    mutation.mutate(data, {
      onSuccess: () => form.reset(),
    });
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
        <Button disabled={mutation.isPending}>
          {mutation.isPending ? "Submitting..." : "Submit"}
        </Button>
        {mutation.isError && (
          <p>{mutation.error.message}</p>
        )}
      </form>
    </Form>
  );
}
```

---

### 13. Best Practices Checklist

When creating a new query or mutation:

- [ ] Query key is defined in `queryKeys.ts`
- [ ] Custom hook is created in `lib/queries/` or `lib/mutations/`
- [ ] API function is separated in `lib/api/`
- [ ] TypeScript types are defined
- [ ] Error handling is implemented
- [ ] Loading states are handled
- [ ] Related queries are invalidated after mutations
- [ ] Query is enabled/disabled appropriately
- [ ] Stale time and cache time are configured
- [ ] Retry logic is configured
- [ ] Component uses the hook correctly

---

### 14. Common Patterns

#### Dependent Queries:
```typescript
export function useUserProfile(userId: string | null) {
  const { data: user } = useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId!),
    enabled: !!userId,
  });
  
  const { data: profile } = useQuery({
    queryKey: ["profile", userId],
    queryFn: () => fetchProfile(userId!),
    enabled: !!userId && !!user, // Depends on user query
  });
  
  return { user, profile };
}
```

#### Parallel Queries:
```typescript
export function useDashboardData() {
  const users = useQuery({ queryKey: ["users"], queryFn: fetchUsers });
  const posts = useQuery({ queryKey: ["posts"], queryFn: fetchPosts });
  const stats = useQuery({ queryKey: ["stats"], queryFn: fetchStats });
  
  return {
    users: users.data,
    posts: posts.data,
    stats: stats.data,
    isLoading: users.isLoading || posts.isLoading || stats.isLoading,
  };
}
```

#### Conditional Queries:
```typescript
export function useConditionalData(shouldFetch: boolean) {
  return useQuery({
    queryKey: ["data"],
    queryFn: fetchData,
    enabled: shouldFetch, // Only fetch when condition is true
  });
}
```

---

## Summary

**Core Principles:**
1. ✅ Always use TanStack Query for data fetching
2. ✅ Always use `useQuery` for GET requests
3. ✅ Always use `useMutation` for POST/PUT/DELETE requests
4. ✅ Always organize queries and mutations in dedicated files
5. ✅ Always invalidate related queries after mutations
6. ✅ Always handle errors and loading states properly

**Key Benefits:**
- Automatic caching and background refetching
- Built-in loading and error states
- Optimistic updates support
- Request deduplication
- Automatic retry logic
- DevTools for debugging
- Better UX with less code
